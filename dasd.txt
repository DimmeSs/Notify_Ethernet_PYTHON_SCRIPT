colored("{NET} Dostepny","light_cyan")
colored("{NET} Niedostepny","light_red")

import threading
import time
import psutil
import socket
import os
from datetime import datetime

os.system("mode con: cols=44 lines=20")
print("============================================\n     Wpisz 'STOP' aby zatrzymać program\n============================================\n\n                V TEXT LOG V\n--------------------------------------------\n")
def log_status(status_message):
    # Pobierz aktualną datę i godzinę
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Informacje o komendach
    
    # Wypisz komunikat w konsoli
    print(f"{timestamp}: {status_message}")

    # Zapisz komunikat do pliku "internet_status.txt"
    with open("internet_status.txt", "a") as f:
        f.write(f"{timestamp}: {status_message}\n")

def check_ethernet_connection():
    last_status = None  # Zmienna do przechowywania ostatniego znanego stanu połączenia
    ethernet_interface = "Ethernet"  # Nazwa interfejsu ethernetowego (może być inna w zależności od systemu)

    while True:
        interfaces = psutil.net_if_stats()

        # Sprawdź, czy interfejs ethernetowy jest aktywny
        if ethernet_interface in interfaces and interfaces[ethernet_interface].isup:
            try:
                # Sprawdź, czy można nawiązać połączenie z adresem IP Google DNS (8.8.8.8) na porcie 53
                # Możesz zmienić adres IP na inny, jeśli wolisz
                socket.create_connection(("8.8.8.8", 53), timeout=5)            
                socket.create_connection(("1.1.1.1", 53), timeout=5)                 
                socket.create_connection(("1.0.0.1", 53), timeout=5)

                # Połączenie sieciowe jest aktywne
                current_status = "Dostęp do internetu :D"
            except socket.error:
                # W przypadku braku połączenia
                current_status = "Brak dostępu do internetu :C"
        else:
            current_status = "Brak dostępu do internetu :C (brak interfejsu Ethernet)"

        if current_status != last_status:
            # Wypisz komunikat w konsoli i zapisz do pliku, tylko jeśli stan się zmienił
            log_status(current_status)

        last_status = current_status

        time.sleep(1)  # Oczekuj 1 sekundę przed kolejnym sprawdzeniem połączenia

# Uruchom funkcję check_ethernet_connection() w tle
thread = threading.Thread(target=check_ethernet_connection)
thread.daemon = True
thread.start()

# Pozwala na ręczne zatrzymanie skryptu po wpisaniu "STOP" w konsoli
try:
    while True:
        command = input("").upper()
        if command == "STOP":
            break
        else:
            print("[Error] Nie ma takiej komendy\n")
except KeyboardInterrupt:
    pass

-------------------------

import threading
import time
import psutil
import socket
import os
from datetime import datetime
from pystray import Icon, Menu, MenuItem
from PIL import Image

os.system("mode con: cols=44 lines=20")
print("============================================\n     Wpisz 'STOP' aby zatrzymać program\n============================================\n\n                V TEXT LOG V\n--------------------------------------------\n")

# Zmienna do przechowywania stanu ukrywania okna
window_hidden = False

def log_status(status_message):
    # Get the current date and time
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Print the message to the console
    print(f"{timestamp}: {status_message}")

    # Write the message to the "internet_status.txt" file
    with open("internet_status.txt", "a") as f:
        f.write(f"{timestamp}: {status_message}\n")

def check_ethernet_connection():
    last_status = None  # Variable to store the last known connection status
    ethernet_interface = "Ethernet"  # Ethernet interface name (might be different based on the system)

    while True:
        interfaces = psutil.net_if_stats()

        # Check if the Ethernet interface is active
        if ethernet_interface in interfaces and interfaces[ethernet_interface].isup:
            try:
                # Check if we can establish a connection with the Google DNS IP (8.8.8.8) on port 53
                # You can change the IP address to another if you prefer
                socket.create_connection(("8.8.8.8", 53), timeout=5)            
                socket.create_connection(("1.1.1.1", 53), timeout=5)                 
                socket.create_connection(("1.0.0.1", 53), timeout=5)

                # Internet connection is active
                current_status = "Internet access :D"
            except socket.error:
                # No internet connection
                current_status = "No internet access :C"
        else:
            current_status = "No internet access :C (no Ethernet interface)"

        if current_status != last_status:
            # Print the message to the console and write to the file only if the status has changed
            log_status(current_status)

        last_status = current_status

        time.sleep(1)  # Wait for 1 second before the next connection check

# Function to toggle window visibility when "hide" is clicked
def toggle_window(icon, item):
    global window_hidden
    window_hidden = not window_hidden
    if window_hidden:
        os.system("mode con: cols=0 lines=0")  # Hide the console
    else:
        os.system("mode con: cols=44 lines=20")  # Restore the console size
        os.system("title Internet Status")  # Restore the console title

# Run the check_ethernet_connection() function in the background
thread = threading.Thread(target=check_ethernet_connection)
thread.daemon = True
thread.start()

# Function to show/hide the console when clicking the tray icon
def on_tray_icon_click(icon, item):
    if item.text == "Show Console":
        toggle_window(icon, item)
    elif item.text == "Hide":
        toggle_window(icon, item)
    else:
        icon.stop()

# Create an icon for the system tray
icon_image = Image.open("icon.png")  # Replace "icon.png" with the path to your custom icon
menu = Menu(MenuItem("Show Console", on_tray_icon_click), MenuItem("Hide", on_tray_icon_click), MenuItem("Exit", on_tray_icon_click))
icon = Icon("Internet Status", icon_image, "Internet Status", menu)
icon.run()

# Pozwala na ręczne zatrzymanie skryptu po wpisaniu "STOP" w konsoli
try:
    while True:
        command = input("").upper()
        if command == "STOP":
            break
        else:
            print("[Error] Nie ma takiej komendy\n")
except KeyboardInterrupt:
    pass


import threading
import psutil
import socket
import os
import ctypes
from datetime import datetime
from pystray import Icon, Menu, MenuItem
from PIL import Image
from termcolor import colored

os.system("mode con: cols=44 lines=30")
print("============================================\n     Wpisz 'STOP' aby zatrzymać program\n============================================\n\n           V DZIENNIK TEKSTOWY V\n--------------------------------------------\n")

# Zmienna do przechowywania stanu ukrywania okna
window_hidden = True

def log_status(status_message, colored_message):
    # Pobierz aktualną datę i godzinę
    timestamp = datetime.now().strftime("|%Y-%m-%d| [%H:%M:%S]")

    # Wypisz kolorowany komunikat w konsoli
    print(f"{timestamp}: "+colored_message)

    # Zapisz komunikat do pliku "internet_status.txt"
    with open("internet_status.txt", "a") as f:
        f.write(f"{timestamp}: {status_message}\n")

def check_ethernet_connection():
    last_status = None  # Zmienna do przechowywania ostatniego znanego stanu połączenia
    ethernet_interface = "Ethernet"  # Nazwa interfejsu ethernetowego (może być inna w zależności od systemu)

    while True:
        interfaces = psutil.net_if_stats()

        # Sprawdź, czy interfejs ethernetowy jest aktywny
        if ethernet_interface in interfaces and interfaces[ethernet_interface].isup:
            try:
                # Sprawdź, czy można nawiązać połączenie z adresem IP XXX na porcie 53

                #XXX Zmień swój adres ip ethernetu zależnie od tego jaki masz ustawiony XXX

                # socket.create_connection(("8.8.8.8", 53), timeout=5)
                socket.create_connection(("1.1.1.1", 53), timeout=5)
                socket.create_connection(("1.0.0.1", 53), timeout=5)

                # Połączenie sieciowe jest aktywne
                current_status = "{NET} Dostepny"
                colored_status = colored(current_status, "light_cyan")

            except socket.error:
                # W przypadku braku połączenia
                current_status = "{NET} Niedostepny"
                colored_status = colored(current_status, "light_red")
        else:
            current_status = "Brak dostępu do internetu :C (jakiś error)"
            colored_status = current_status

        if current_status != last_status:
            # Wypisz komunikat w konsoli i zapisz do pliku, tylko jeśli stan się zmienił
            log_status(current_status, colored_status)

        last_status = current_status


# Funkcja do minimalizowania lub przywracania okna konsoli
def toggle_window(icon, item):
    global window_hidden
    console_handle = ctypes.windll.kernel32.GetConsoleWindow()
    console_visible = ctypes.windll.user32.IsWindowVisible(console_handle)

    if console_visible:
        ctypes.windll.user32.ShowWindow(console_handle, 0)  # Minimalizuj okno konsoli
        window_hidden = True
    else:
        ctypes.windll.user32.ShowWindow(console_handle, 5)  # Przywróć okno konsoli
        window_hidden = False

    # Zaktualizuj menu w zasobniku systemowym na podstawie aktualnego stanu okna konsoli
    update_system_tray_menu(icon)

# Funkcja do pokazywania/ukrywania konsoli po kliknięciu w ikonkę zasobnika systemowego
def on_tray_icon_click(icon, item):
    if item.text == "Pokaż / Ukryj konsolę":
        toggle_window(icon, item)
    elif item.text == "Pokaż / Ukryj konsolę":
        toggle_window(icon, item)
    elif item.text == "Zakończ":
        icon.stop()
        os._exit(0)  # Wymuszenie zamknięcia programu

# Funkcja do aktualizacji menu w zasobniku systemowym na podstawie aktualnego stanu okna konsoli
def update_system_tray_menu(icon):
    global window_hidden

    menu_items = [
        MenuItem("Pokaż / Ukryj konsolę", on_tray_icon_click) if not window_hidden else MenuItem("Pokaż / Ukryj konsolę", on_tray_icon_click),
        MenuItem("Zakończ", on_tray_icon_click)
    ]

    # Utwórz nowy obiekt Menu i przypisz go do atrybutu menu dla ikony
    icon.menu = Menu(*menu_items)

# Utwórz ikonę dla zasobnika systemowego
icon_image = Image.open("icon.png")

menu = Menu(MenuItem("Pokaż / Ukryj konsolę", on_tray_icon_click), MenuItem("Zakończ", on_tray_icon_click))

icon = Icon("Stan Internetu", icon_image, "Stan Internetu", menu)

# Uruchom funkcję check_ethernet_connection() w tle
thread = threading.Thread(target=check_ethernet_connection)
thread.daemon = True
thread.start()

# Zaktualizuj menu w zasobniku systemowym
update_system_tray_menu(icon)

# Uruchom icon.run() w oddzielnym wątku, aby obsłużyć zdarzenia zasobnika systemowego
icon_thread = threading.Thread(target=icon.run)
icon_thread.daemon = True
icon_thread.start()

# Utrzymuj działanie głównego wątku, aby obsługiwać wprowadzanie w konsoli
try:
    while True:
        command = input("").upper()
        if command == "STOP":
            break
        elif command == "HIDE":
            toggle_window(icon, None)  # Ukryj okno konsoli
        else:
            print("[Błąd] Nieznana komenda\n")
except KeyboardInterrupt:
    pass
